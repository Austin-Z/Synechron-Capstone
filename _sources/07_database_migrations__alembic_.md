# Chapter 7: Database Migrations (Alembic)

Welcome back! In [Chapter 6: AI Service (GeminiService)](06_ai_service__geminiservice_.md), we saw how our application can use AI to intelligently interact with the fund data we've collected and organized. We have our data collector, database models, manager, loading scripts, and even smart services working together.

## The Problem: Changing the Blueprints After Building

Imagine you've built a house using a set of blueprints ([Database Models (SQLAlchemy)](02_database_models__sqlalchemy_.md)). People have moved in, and furniture (data) is already placed inside. Now, you realize you need to add a new window to the living room or change the plumbing layout. How do you update the house safely without disrupting everything or losing track of the changes you made?

Similarly, in software development, your database structure (schema) often needs to evolve. You might realize you need to:

*   Add a new column to the `funds` table (e.g., a `nickname` for a fund).
*   Change the data type of an existing column.
*   Add a completely new table.

If you just manually change the database, how do you keep track of these changes? How do you ensure the same changes are applied correctly when your teammates run the code, or when you deploy the application to a server? Doing this manually is risky and prone to errors.

## Meet Alembic: Version Control for Your Database

Think of **Alembic** as **version control for your database structure**, much like Git is version control for your code. It's a powerful Python library specifically designed to work with SQLAlchemy (which we use for our [Database Models (SQLAlchemy)](02_database_models__sqlalchemy_.md)).

Alembic helps us manage changes to our database schema in a safe, organized, and repeatable way. It allows us to:

1.  **Track Changes:** It keeps a history of every change made to the database structure.
2.  **Generate Instructions:** When you change your SQLAlchemy models (our blueprints), Alembic can automatically compare the models to the current database structure and generate Python scripts containing the instructions (SQL commands) needed to update the database. These scripts are called **migration scripts**.
3.  **Apply Changes Step-by-Step:** You can apply these migration scripts one by one to safely evolve your database schema.
4.  **Revert Changes (Downgrade):** If something goes wrong, Alembic usually allows you to revert (downgrade) the database back to a previous version.
5.  **Ensure Consistency:** Everyone on the team and all deployment environments (development, testing, production) can use the same migration scripts to ensure their database structures are identical and up-to-date.

## Key Concepts Explained

*   **Migration Script:** A Python file generated by Alembic (usually stored in the `alembic/versions/` directory). It contains two main functions:
    *   `upgrade()`: Describes the changes needed to move the database schema *forward* to this version (e.g., add a column, create a table).
    *   `downgrade()`: Describes how to *undo* the changes made by `upgrade()` (e.g., remove the column, drop the table).
*   **Revision:** A unique ID assigned by Alembic to each migration script (e.g., `5dde2311e9b7`, `1a2b3c4d5e6f`). This acts like a version number for your database schema.
*   **Schema:** The structure of your database â€“ the tables, columns, data types, relationships (foreign keys), etc. This is defined by our [Database Models (SQLAlchemy)](02_database_models__sqlalchemy_.md).
*   **Autogenerate:** An Alembic command (`alembic revision --autogenerate`) that automatically compares your current SQLAlchemy models (`Base.metadata`) against the schema of the actual database. It detects differences and creates a new migration script draft containing the necessary `upgrade` and `downgrade` operations. You should always review these auto-generated scripts!
*   **`alembic_version` Table:** Alembic creates a special table in your database called `alembic_version`. It uses this table to keep track of which migration revision (version) your database is currently at.

## How to Use Alembic: The Workflow

Let's walk through a common scenario: adding a new `nickname` column to our `Fund` model.

**Step 1: Modify Your Model**

First, you update the blueprint in your Python code.

```python
# File: src/models/database.py (Simplified change)
from sqlalchemy import Column, Integer, String, Enum, DateTime # Add String
# ... other imports ...
Base = declarative_base()

class Fund(Base):
    __tablename__ = 'funds'
    id = Column(Integer, primary_key=True)
    ticker = Column(String(10), unique=True, nullable=False)
    name = Column(String(255), nullable=False)
    fund_type = Column(Enum('fund_of_funds', 'underlying_fund', name='fund_type'))

    # --- NEW COLUMN ADDED ---
    nickname = Column(String(50), nullable=True) # Add a nickname field
    # ------------------------

    filings = relationship("Filing", back_populates="fund")
    # ... rest of the class ...
```

*   We simply added a new line `nickname = Column(String(50), nullable=True)` to our `Fund` class definition.

**Step 2: Generate the Migration Script**

Now, ask Alembic to compare your updated models with the database and generate the instructions. Open your terminal in the project's root directory and run:

```bash
alembic revision --autogenerate -m "Add nickname column to Fund table"
```

*   **Input:** The command tells Alembic to:
    *   `revision`: Create a new migration file.
    *   `--autogenerate`: Automatically detect changes by comparing models to the DB.
    *   `-m "..."`: Add a descriptive message to the migration file name.
*   **Output:** Alembic connects to the database (using the URL configured in `alembic.ini` or `alembic/env.py`), inspects its current structure, compares it to your `Fund` model (and others), sees the new `nickname` field, and creates a new file like `alembic/versions/xxxxxxxxxxxx_add_nickname_column_to_fund.py`. You'll see output confirming the file creation.

**Step 3: Review the Generated Script**

*Crucially, always open and review the script Alembic generated!* Autogenerate is helpful but not perfect.

```python
# File: alembic/versions/xxxxxxxxxxxx_add_nickname_column_to_fund.py (Simplified)
"""Add nickname column to Fund table

Revision ID: xxxxxxxxxxxx
Revises: 1a2b3c4d5e6f # Points to the previous migration
Create Date: 2023-10-27 10:00:00.000000

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = 'xxxxxxxxxxxx' # The unique ID for this change
down_revision = '1a2b3c4d5e6f' # The ID of the migration before this one
branch_labels = None
depends_on = None

def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # Instruction to add the new 'nickname' column to the 'funds' table
    op.add_column('funds', sa.Column('nickname', sa.String(length=50), nullable=True))
    # ### end Alembic commands ###

def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # Instruction to remove the 'nickname' column from the 'funds' table
    op.drop_column('funds', 'nickname')
    # ### end Alembic commands ###
```

*   This script contains the `upgrade` function, which uses `op.add_column` to add our new field.
*   It also contains the `downgrade` function, using `op.drop_column` to remove it if we need to revert.
*   It correctly identifies the `revision` ID and the `down_revision` (the previous migration).

**Step 4: Apply the Migration**

If the script looks correct, tell Alembic to apply it to the database:

```bash
alembic upgrade head
```

*   **Input:** This command tells Alembic to:
    *   `upgrade`: Apply pending migrations.
    *   `head`: Apply all migrations up to the latest one (the "head" revision).
*   **Output:** Alembic connects to the database, checks the `alembic_version` table to see which revision the database is currently at, finds any newer migration scripts (like our `add_nickname_column...` script), executes their `upgrade()` functions in order, and updates the `alembic_version` table to reflect the new state (`xxxxxxxxxxxx`). You'll see logs indicating which revisions are being applied. Your `funds` table in the database now has the `nickname` column!

**Step 5: (Optional) Reverting a Migration**

If you realize you made a mistake immediately after upgrading, you can often revert the last change:

```bash
alembic downgrade -1
```

*   **Input:** This command tells Alembic to:
    *   `downgrade`: Revert migrations.
    *   `-1`: Revert exactly one revision from the current state.
*   **Output:** Alembic connects to the database, checks the current revision in `alembic_version`, finds the migration script corresponding to that revision, executes its `downgrade()` function, and updates the `alembic_version` table to the previous revision ID. Your `nickname` column would be removed.

## Under the Hood: How Alembic Works

Let's visualize the `autogenerate` and `upgrade` process:

1.  **Change Model:** Developer modifies `src/models/database.py` (adds `nickname`).
2.  **Run `autogenerate`:**
    *   Alembic loads your models (`Base.metadata`).
    *   Alembic connects to the database and checks the current schema.
    *   Alembic reads the latest revision ID from the `alembic_version` table in the database.
    *   Alembic compares the models' structure to the database structure.
    *   It detects the missing `nickname` column in the `funds` table.
    *   It generates a new Python migration script (`xxxxxxxxxxxx_...py`) with `op.add_column` in `upgrade()` and `op.drop_column` in `downgrade()`, setting `down_revision` to the previous latest ID.
3.  **Run `upgrade head`:**
    *   Alembic connects to the database.
    *   It reads the current revision ID from the `alembic_version` table.
    *   It looks in the `alembic/versions` directory for any migration scripts with revision IDs newer than the current one.
    *   It finds `xxxxxxxxxxxx_...py`.
    *   It executes the `upgrade()` function inside `xxxxxxxxxxxx_...py`. This function uses SQLAlchemy's `op` object to send the actual `ALTER TABLE funds ADD COLUMN nickname VARCHAR(50);` SQL command to the database.
    *   After successfully executing the `upgrade()` function, Alembic updates the `alembic_version` table to store the new revision ID (`xxxxxxxxxxxx`).

```{mermaid}
sequenceDiagram
    participant Dev as Developer
    participant Models as database.py
    participant AlembicCLI as Alembic CLI
    participant DBMeta as Database Schema
    participant AlembicVer as alembic_version Table
    participant MigrationScript as Migration Script File

    Dev->>Models: Add 'nickname' column definition
    Dev->>AlembicCLI: alembic revision --autogenerate ...
    AlembicCLI->>Models: Load Base.metadata
    AlembicCLI->>DBMeta: Inspect current schema
    AlembicCLI->>AlembicVer: Get current revision ID
    AlembicCLI->>AlembicCLI: Compare Models vs DB Schema
    AlembicCLI->>MigrationScript: Generate xxxxxxxx_...py (with op.add_column)

    Dev->>AlembicCLI: alembic upgrade head
    AlembicCLI->>AlembicVer: Get current revision ID
    AlembicCLI->>MigrationScript: Find newer scripts (xxxxxxxx_...py)
    AlembicCLI->>MigrationScript: Execute upgrade() function
    MigrationScript->>DBMeta: Send ALTER TABLE SQL command
    DBMeta-->>MigrationScript: Command successful
    MigrationScript-->>AlembicCLI: upgrade() finished
    AlembicCLI->>AlembicVer: Update revision ID to xxxxxxxx
```

## Diving Deeper into the Code

**Configuration (`alembic/env.py`)**

This file tells Alembic how to find your database and your models.

```python
# File: alembic/env.py (Simplified)
from logging.config import fileConfig
from sqlalchemy import engine_from_config, pool, create_engine
from alembic import context

# --- Crucial Part 1: Tell Alembic about your models ---
# Import the Base object from your models file
from src.models.database import Base
# Set the target_metadata so Alembic knows what structure your models define
target_metadata = Base.metadata
# -------------------------------------------------------

# Import settings to get the database URL
from src.config import Settings
import os

# --- Crucial Part 2: Tell Alembic how to connect ---
settings = Settings()
database_url = settings.database_url # Get DB URL from config/env vars

# Get the Alembic Config object, used in practice below
config = context.config

# Set the database URL for Alembic to use
config.set_main_option('sqlalchemy.url', database_url)
# ----------------------------------------------------

# ... (Rest of the file contains functions to run migrations online/offline) ...

def run_migrations_online() -> None:
    """Run migrations in 'online' mode."""
    # Connect to the database using the configured URL
    connectable = create_engine(database_url)

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            # Pass the target_metadata for comparison during autogenerate
            target_metadata=target_metadata
        )
        with context.begin_transaction():
            # Execute the migration steps (runs upgrade() or downgrade())
            context.run_migrations()

if context.is_offline_mode():
    # ... (offline setup) ...
else:
    run_migrations_online() # Standard mode
```

*   `target_metadata = Base.metadata`: This line is vital. It points Alembic to the collective structure defined by all your SQLAlchemy models that inherit from `Base`. Alembic uses this for the `autogenerate` comparison.
*   `config.set_main_option('sqlalchemy.url', database_url)`: This tells Alembic the address of the database it needs to connect to and modify.
*   The `run_migrations_online` function shows how Alembic uses this information to establish a connection and configure its context, passing the `target_metadata` along.

**Example Migration Script (`alembic/versions/add_fund_type.py`)**

Let's look at a slightly more complex (but still simplified) migration script provided in the project. This one adds the `fund_type` column we saw in our models earlier.

```python
# File: alembic/versions/add_fund_type.py (Simplified)
"""add fund type column

Revision ID: 1a2b3c4d5e6f
Revises: 5dde2311e9b7 # Points to the initial schema migration
Create Date: 2024-03-21

"""
from alembic import op # Import Alembic operations module
import sqlalchemy as sa # Import SQLAlchemy core components

# revision identifiers, used by Alembic.
revision = '1a2b3c4d5e6f'
down_revision = '5dde2311e9b7' # Depends on the initial schema being present
branch_labels = None
depends_on = None

def upgrade():
    # Define the ENUM type we want to use
    fund_type_enum = sa.Enum('fund_of_funds', 'underlying_fund', name='fund_type')

    # Add the column, initially allowing NULLs
    op.add_column('funds',
        sa.Column('fund_type', fund_type_enum, nullable=True)
    )

    # --- (Complex logic to populate the new column based on existing data - simplified here) ---
    # In the real script, this uses SQL to guess the fund_type based on holdings.
    print("INFO: Populating fund_type (skipping complex SQL for this example)")
    # op.execute(""" UPDATE funds SET fund_type = ... WHERE ... """) # Real script has SQL here
    # -----------------------------------------------------------------------------------------

    # Alter the column to make it NOT NULL after populating
    op.alter_column('funds', 'fund_type',
                    existing_type=fund_type_enum,
                    nullable=False)

def downgrade():
    # To revert, simply drop the column
    op.drop_column('funds', 'fund_type')
    # If we used a separate ENUM type, we might need to drop that too
    # op.execute("DROP TYPE fund_type;") # Depending on DB
```

*   The `upgrade` function first uses `op.add_column` to add the `fund_type` column.
*   It then might contain custom SQL (`op.execute`) or other logic to populate initial values for existing rows.
*   Finally, it uses `op.alter_column` to enforce the `NOT NULL` constraint.
*   The `downgrade` function simply uses `op.drop_column` to remove the column entirely.

These migration files, stored in `alembic/versions`, create a repeatable, version-controlled history of how your database schema has evolved.

## Conclusion

You've now learned about Database Migrations and the Alembic tool!

*   **Why it's needed:** To manage changes to your database structure (schema) safely and consistently over time, especially when working in a team or across different environments.
*   **What it does:** Tracks schema changes, generates migration scripts (with `upgrade` and `downgrade` instructions), applies these changes step-by-step, and allows reverting changes. Think "Git for your database schema."
*   **Key Workflow:** Modify Models -> `alembic revision --autogenerate` -> Review Script -> `alembic upgrade head`.
*   **Key Components:** Migration scripts (`alembic/versions/`), `alembic.ini` & `alembic/env.py` for configuration, `op` commands (`op.add_column`, `op.drop_table`, etc.) inside scripts.

Alembic is an essential tool for maintaining database health and consistency throughout the lifecycle of your project. It ensures that changes to your [Database Models (SQLAlchemy)](02_database_models__sqlalchemy_.md) are reflected correctly and safely in the actual database.

We've now covered almost all the core components of the FOFs-Capstone project! From collecting data, defining models, managing the database, loading data, providing services, using AI, and managing schema changes. But how does the application know things like the database password, API keys, or other settings?

**Next Up:** Let's look at how the application manages configuration securely and efficiently in [Chapter 8: Application Configuration (Settings)](08_application_configuration__settings_.md).

---

Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)